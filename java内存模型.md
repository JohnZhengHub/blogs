# Java内存模型

## 背景
 现代的处理器使用写缓冲区临时保存向内存写入的数据,写缓冲区可以保证指令流水线持续运行,它可以避免由于处理器停顿下来等待向内存写如数据而产生延迟.但由于每个处理器上的写缓冲区仅仅对它所在的处理器可见,所以导致处理器对内存的读写操作的执行顺序可能与内存实际操作的执行顺序不一致.

## 内存模型定义
　Java内存模型的主要目标是**定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样底层细节。它决定了一个线程对共享变量的写入何时对另一个线程可见**。它属于语言及的内存模型，它确保在不同编译器和不同的处理平台之上，通过**禁止特定类型的编译器重排序和处理器重排序**，为程序员提供一致的内存可见性保证。
　
  JMM的核心目标是找到一个好的平衡点，一方面是为**程序员**提供足够强的内存可见性保证（提供**happens-before**规则），另一方面对编译器和处理器的限制尽可能地放松（只要不改变程序结果，怎么优化都可以）。

## 对程序员可见性保证
### happen-before原则
JMM向程序员保证,如果一个操作执行的结果需要对另一个操作可见，那么这两个操作(同一个线程或不同线程)必须存在happens-before关系。
 - **程序顺序规则**：一个线程的每个操作happen-before与该线程的任意后续操作。
 - **监视器锁规则**：一个锁的解锁，happens-before于随后这个锁的加锁。
 - **Volatile变量规则**：对一个volatile域的写，happens-before于任意后续这个域的读。
 - **传递性规则**
 - **Start()规则**：如果线程A执行操作ThreadB.start().那么线程A中的任意操作happens-before与线程B中的任意操作。
 - **Join()规则**：如果线程A执行操作ThreadB.join()并成功返回，那么B中的任意操作Happens-before于线程A。

### 禁止重排序
重排序：在执行过程中为了提高性能,编译器和处理器常常会对指令左重拍序,重排序可以分为3类:
 - 编译器优化重排序:编译器在不改变单线程程序语的前提下,可以重新排序语义的执行顺序.
 - 指令级并行的重排序:多处理器在运行时可以并行执行多条指令,导致指令的重排序.
 - 内存系统的重排序: 由于处理器使用缓存和读/写缓冲区,这使得加载和存储操作可能乱序执行.

为了保证内存的可见性,和实现happen-before,JMM提供了四类内存屏障指令来禁止特定类型的重排序,分别是:
 - LoadLoad Barriers : 确保load1数据加载先于load2及所有后续装载指令的装载
 - StoreStore Barriers : 确保Store1数据对其他处理器可见,先于store2及后续存储指令的存储
 - LoadStore Barriers : 确保load数据转载先于store2即所有后续存储指令刷新到内存中
 - StoreLoad Barriers : 确保store1数据对其他处理器变得可见.

## 对编译器的规定
对会改变(单线程或正确同步)程序执行结果的重排序,JMM要求编译器和处理器禁止重排序,对于不会改变执行结果的重排序,JMM对编译器和处理器不做要求.
 1. 在单线程环境中,为了保证as-if-serial(不管怎么重排序结构都一样).编译器和处理器不会对存在数据依赖关系的操作重排序.
数据依赖性：如果两个操作访问同一个变量，有一个操作为写操作，这两个操作存在数据依赖性。在单线程环境中，编译器和处理器的重排序会遵守数据依赖性
 2. 在单线程环境下可以对控制依赖关系做重排序,不改变执行结果.
 3. 在正确同步的情况下,JMM在临界区内允许代码重排序,但不允许临界区内的代码溢出到临界区外,那样会破坏监视器的语义.
 4. 在未同步或为正确同步的多线程程序中,JMM只提供最小安全:线程执行读取到的值要么是之前某个程序写入的值,要么是默认值.这种情况下不保证顺序一致性原则,所以允许编译器重排序.
 5. JMM不保证对64位的long型和double型变量的写操作都具有原子性.

## 其他概念

As-if-serial: 不管怎么重排序，单线程执行的结果不能被改变。另外JMM不保证对64位的long和double型变量的写操作具有原子性。

As-if-serial保证了单线程环境下结果的正确性，JMM为多线程提供以下保证。如果程序是正确同步的那么程序的执行将具有一致性。顺序一致性是具有量大特性：所有操作按顺序执行；所有线程都只能看到一个单一的操作顺序。未正确同步的程序JMM不但整体的执行顺序是无序的，而且线程看到的操作顺序是不一致的。
