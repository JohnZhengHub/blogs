## volatile的理解
volatile不会引起上下文切换

**Volatile自身特性**：

1. Volatile 是轻量级的synchronized，它在多处理器开发过程中保证了共享变量的“**可见性**”.

可见性是指当一个线程的某个共享变量发生改变时，另一个线程能够读取到这个修改的值。Voaltile变量修饰的变量在进行写操作时在多核处理器下首先JVM会向处理器发送一条**Lock前缀的指令**将当前处理器缓存行的数据写回到系统内存中。Lock指令会锁定这块内存区域的缓存并写会到内存,使用缓存一致性机制来确保修改的原子性,此操作称作"缓存锁定",缓存一致性机制阻止两个以上处理器同时修改它们缓存的统一块内存区域.

为了保证缓存的一致性，每个处理器通过**嗅探**到总线上传播的数据来检查自己缓存的值是过期了,当处理器发现自己缓存行对应的数据被修改了就会将当前处理器缓存设置为无效状态,当处理器对这个数据进行修改操作时会重新从系统内存中把数据读到处理器缓存里.

2. Volatile 可以**禁止重排序**，

3. Volatile 能保持单个简单volatile变量的读/写操作的具有原子性。但不能保证自增自减的原子性。	

从**内存语义**来讲:

volatile变量的写-读与锁的释放-获取具有相同语义，volatile的写与锁的释放有相同的内存语义，volatile读与锁的获取具有相同语义。
 - 线程A写一个volatile变量，实质上是线程A向接下来要读这个volatile变量的某个线程发出消息
 - 线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的消息。
 - 线程A写volatile变量，随后线程B读这个变量，这个过程实质上线程A通过内存向B发送消息。

内存语义的实现，也是禁止重排序特性：为了实现volatile内存语义，JMM限制了对volatile重排序做了限制：
 1. 当第二个操作是volatile写时，不管第一个操作时什么，都不能重排序。
 2. 当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。
 3. 当第一个操作是volatile写，第二个操作是volatile读时，不重排序。
 
为了实现volatile的内存语义，编译器生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。JMM采取保守策略。

1. 在每个volatile写操作前面插入一个StoreStore屏障
2. 在每个volatile写操作后面插入一个StoreLoad屏障
3. 在每个volatile读操作后面插入一个LoadLoad屏障
4. 在每个volatile读操作后面插入一个LoadStore屏障
