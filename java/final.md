对于final域编译器和处理器要遵守两个重排序规则：
 1. 在构造器函数内对final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。（保证了对象引用为任何线程可见之前，对象的final域已经被正确初始化过）
 2. 初次读一个包含final域的对象引用，与随后初次读这个final域这两个操作不能重排序。

## 写final域
写final域的重排序规则禁止final域的写重排序到构造器之外.这个规则的实现有两个方面
 1. JMM禁止编译器把final域的写重排序到构造函数之外
 2. 编译器会对final写之后,构造函数return之前插入一个StoreStore屏障.这个屏障禁止处理器把final域写重排序到构造函数之外.

**写final域的重排序规则可以保证:在对象引用为任意线程可见之前,对象的fianal域已经被确认初始化过,而普通域不具有这个屏障**.
为何保证其内存语义：可以为java程序员提供安全保证，只要对象是正确构造的，那么不需要使用同步就可以保证线程都能看到这个fianal域在构造函数中被初始化之后的值。

## 读final域
初次读一个包含final域的对象引用，与随后初次读这个final域这两个操作不能重排序。因为这两个之前存在数据依赖关系,所以编译器会在读final域操作的前面插入一个loadload屏障.

## 为什么要保证fianl语义
之前的java内存模型的缺陷是,线程可能看到final域的值会改变,通过为final域增加读写重排序规则,可以为java程序员提供初始化安全保证:只要对象是正确构造的,那么不需要使用同步,就可以保证线程能看到这个final域在构造函数中被初始化之后的值.

