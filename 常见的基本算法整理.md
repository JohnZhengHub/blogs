
		}
		for(int a:result){
			System.out.print(a+" ");
		}
		return result;
	}


#### 背包问题

	public static void knapsack(int[][] S,int W){
		int n=S[0].length;
		int[] sort=new int[n];
		for(int i=0;i<n;i++)
			sort[i]=i;
		quickSort(S,sort,0,n-1);
		int i=0;
		double w=W,x;
		while(w>0){
			x=Math.min(1,w/S[0][sort[i]]);
			System.out.println((sort[i]+1)+"  "+x);
			w=w-x*S[0][sort[i]];
			i++;
		}
	}
	
	private static void quickSort(int[][] s, int[] sort,int left,int right) {
		if(left<right){
			int p=partition(s,sort,left,right);
			quickSort(s,sort,left,p-1);
			quickSort(s,sort,p+1,right);
		}
	}

	private static int partition(int[][] s, int[] sort, int left, int right) {
		int tempIdx=sort[left];
		int temp=s[1][tempIdx]/s[0][tempIdx];
		
		while(left<right){
			while(left<right && s[1][sort[right]]/s[0][sort[right]]<temp) right--;
			sort[left]=sort[right];
			
			while(left<right && s[1][sort[left]]/s[0][sort[left]]>temp) left++;
			sort[right]=sort[left];
		}
		sort[left]=tempIdx;
		return left;
	}


#### 缓存维护问题

	public static void caching(int[] pages,int cacheCapocity){
		int[] cache=new int[cacheCapocity+1];
		int top=0,rear=0;
		int count=0;
		for(int i=0;i<pages.length;i++){
			if(rear==top || (top+pages.length-rear)%pages.length<cacheCapocity){
				cache[top]=pages[i];
				top=(top+1)%cache.length;
			}if(!exist(pages[i],cache,top,rear)){
				rear=(rear+1)%cache.length;
				cache[top]=pages[i];
				top=(top+1)%cache.length;
				count++;
			}
		}
		System.out.println(count);
	}
	private static boolean exist(int x, int[] cache,int top,int rear) {
		while(rear!=top){
			if(cache[rear]==x) return true;
			rear=(rear+1)%cache.length;
		}
		return false;
	}
