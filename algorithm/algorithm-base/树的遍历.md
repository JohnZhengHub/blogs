
## 一.前序遍历
前序遍历按照“根结点-左孩子-右孩子”的顺序进行访问。
 1.递归实现
   
     public void preOrder(TreeNode root){
    		if(root == null)
    			return;
    		System.out.println(root.val);
    		preOrder(root.left);
    		preOrder(root.right);
    	}

 2. 非递归实现
 根据前序遍历访问的顺序，优先访问根结点，然后再分别访问左孩子和右孩子。即对于任一结点，其可看做是根结点，因此可以直接访问，访问完之后，若其左孩子不为空，按相同规则访问它的左子树；当访问其左子树时，再访问它的右子树。因此其处理过程如下：

  对于任一结点P：
 1. 访问结点P，并将结点P入栈;
 2. 判断结点P的左孩子是否为空，若为空，则取栈顶结点并进行出栈操作，并将栈顶结点的右孩子置为当前的结点P，循环至1);若不为空，则将P的左孩子置为当前的结点P;
 3. 直到P为NULL并且栈为空，则遍历结束。

  /**
	 * 非递归前序遍历
	 * @param node
	 */
	public void preOrder(TreeNode root){
		if(root == null)
			return;
		Stack<TreeNode> stack = new Stack<TreeNode>();
		stack.push(root);
		TreeNode node = root;
		while(node != null || !stack.isEmpty()){
			while(node != null){
				System.out.println(node.val);
				stack.push(node);
				node = node.left;
			}
			if(!stack.isEmpty()){
				node = stack.pop();
				node = node.right;
			}			
		}
	}

	
	
